(ns on-lisp.chap19
  (:require
    [on-lisp.utils :refer [mac cl-atom with-gensyms]]
    [on-lisp.chap18 :refer [match binding vars-in simple? pat-match]]))

;;; 19 - A Query Compiler

;;; ---------------------------------------------------------------------------
;;; 19.1 The Database

;;; Figure 19.1: Basic database functions

(defn make-db []
  {}) 

(def default-db (atom (make-db)))

(defn clear-db 
  ([]
   (clear-db default-db))
  ([db]
   (reset! db {})))
  
(defn db-query
  ([key]
   (db-query key default-db))
  ([key db]
   (get @db key)))

(defn db-push 
  ([key val]
   (db-push key val default-db))
  ([key val db]
   (swap! db update key conj val)))

(defmacro fact [pred & args]
  `(do (db-push '~pred '~args)
       '~args))

#_(fact painter reynolds joshua english)
#_(fact painter canale antonio venetian)
#_(db-query 'painter)


;;; ---------------------------------------------------------------------------
;;; 19.2 Pattern-Matching Queries

;;; Figure 19.2: Syntax of queries.

(comment 
  "{query}    : ({symbol} {argument}*)
              : (not {query})
              : (and {query}*)
              : (or {query}*)
   {argument} : ?{symbol}
              : {symbol}
              : {number}")

;;; ---------------------------------------------------------------------------
;;; 19.3 A Query Interpreter
  
;;; Figure 19.3: Query Interpreter

(defn lookup
  "The function `lookup` takes a pattern consisting of a predicate and a 
  list of arguments, and returns a list of all the bindings which make the 
  pattern match some fact in the database.
  It gets all the database entries for the predicate, and calls `match` to
  compare each of them against the pattern. Each successful match returns
  a list of bindings, and `lookup` in turn returns a list of all these lists."
  ([pred args]
   (lookup pred args {}))
  ([pred args binds]
   (->> (db-query pred)
        (map #(match % args binds))
        (remove nil?))))

#_(lookup 'painter '[?x ?y english]) 
; => ({?x reynolds, ?y joshua} {?x hogarth, ?y william})

(declare interpret-query)

(comment
  "The not operator will filter out bindings which are already generated, as in
  (and (painter ?x ?y ?z) (not (dates ?x 1772 ?d)))
  but you cannot expect it to generate bindings all by itself. We have to 
  generate bindings by looking for painters before we can screen out the ones 
  not born in 1772.")
(defn interpret-not [clause binds]
  (when-not (seq (interpret-query clause binds))
    (list binds)))

(comment
  "Expressions of the form (or q1...qn) are only guaranteed to generate real
  bindings for variables which appear in all of the qi. If a `with-answer`
  contained the query
  (or (painter ?x ?y ?z) (dates ?x ?b ?d))
  you could expect to use the binding of ?x, but neither ?y nor ?b is 
  guaranteed to get a binding from the query, though one or the other will.")
(defn interpret-or [clauses binds]
  (mapcat #(interpret-query % binds)
          clauses))

(defn interpret-and [clauses binds]
  (if-not (seq clauses)
    (list binds)
    (mapcat #(interpret-query (first clauses) %)
            (interpret-and (rest clauses) binds))))

(defn interpret-query 
  "Recursively works through the structure of a complex query, generating
  bindings in the process. The evaluation of complex queries proceeds left-
  to-right, as in Lisp itself. When the recursion gets down to patterns for 
  facts `interpret-query` calls` lookup`. This is where the 
  pattern-matching occurs."
  ([expr]
   (interpret-query expr {}))
  ([expr binds]
   (case (first expr)
     and (interpret-and (reverse (rest expr)) binds)
     or  (interpret-or (rest expr) binds)
     not (interpret-not (first (rest expr)) binds)
     (lookup (first expr) (rest expr) binds))))

#_(interpret-query '(and [painter ?x ?y ?z]
                         [dates ?x 1697 ?w]))
; => [{?w 1768, ?z venetian, ?y antonio, ?x canele}
;     {?w 1772, ?z english, ?y william, ?x hogarth}]

(comment
  "The results are then filtered or combined depending on the surrounding
  logical operators. The final result is returned as a list of sets of 
  bindings.")


(comment
  "As a general rule, queries can be combined and nested without restriction.
  In a few cases there are subtle restrictions on the syntax of queries, but
  these are best dealt with after looking at some examples of how this code
  is used.")

(defmacro with-answer 
  "Takes as its first argument any legal query; the rest of the arguments
  are treated as a body of code. A `with-answer` expands into code which 
  collects all the sets of bindings generated by the query, then iterates
  through the body with the variables in the query bound as specified by
  each set of bindings. Variables which appear in the query of a 
  `with-answer` can (usually) be used within its body. When the query is 
  successful but contains no variables, `with-answer` evaluates the body 
  of code just once."
  [query & body]
  (let [binds (gensym)]
    `(doseq [~binds (interpret-query '~query)]
       (let [~@(mapcat (fn [v]
                         `(~v (binding '~v ~binds)))
                       (vars-in query cl-atom))]
         ~@body))))


;;; Figure 19.4: Assertion of simple facts.

(defn reset-facts! []
  (clear-db)
  (fact painter hogarth william english)
  (fact painter canale antonio venetian)
  (fact painter reynolds joshua english)
  (fact dates hogarth 1697 1772)
  (fact dates canale 1697 1768)
  (fact dates reynolds 1723 1792))
#_(reset-facts!)

;;; Figure 19.5: The query interpreter in use.

;; The first name and nationality of every painter called Hogarth.
#_
(with-answer [painter hogarth ?x ?y]
  (prn (list ?x ?y)))

;; The last name of every painter born in 1697.
#_
(with-answer (and [painter ?x _ _]
                  [dates ?x 1697 _])
  (prn (list ?x)))

;; The last name and year of birth of everyone who died in 1772 or 1792.
#_
(with-answer (or [dates ?x ?y 1772]
                 [dates ?x ?y 1792])
  (pr (list ?x ?y)))

;; The last name of every English painter not born the same year as
;; a Venetian one.
;; This one is bugged.
#_
(with-answer (and [painter ?x _ english]
                  [dates ?x ?b _]
                  (not (and [painter ?x2 _ venetian]
                            [dates ?x2 ?b _])))
  (pr ?x))


;;; ---------------------------------------------------------------------------
;;; 19.5 A Query Compiler

; TODO: fix pat-match

(declare compile-query)

(defn compile-not [q body]
  `(if (try
         ~(compile-query q `(throw (Exception. "return")))
         true
         (catch Exception e#
           (if (= (.getMessage e#) "return")
             nil
             (println (.getMessage e#)))))
     ~@body))
     

(defn compile-or [clauses body]
  (when (seq clauses)
    (let [gbod (gensym)
          vars (vec (vars-in body simple?))]
      `(letfn [(~gbod ~vars ~body)]
         ~@(map #(compile-query % `(~gbod ~@vars))
                clauses)))))
                  
(defn compile-and [clauses body]
  (if-not (seq clauses)
    body
    (compile-query (first clauses)
                   (compile-and (rest clauses) body))))

(defn compile-simple [q body]
  (let [fact (gensym)]
    `(doseq [~fact (db-query '~(first q))]
       (pat-match ~(rest q) ~fact ~body nil))))

(defn compile-query [q body]
  (case (first q)
    and  (compile-and (rest q) body)
    or   (compile-or (rest q) body)
    not  (compile-not (first (rest q)) body)
    lisp `(if ~(first (rest q)) ~body)
    (compile-simple q body)))

(defmacro with-answer [query & body]
  `(with-gensyms [~@(vars-in query simple?)]
     ~(compile-query query `(do ~@body))))